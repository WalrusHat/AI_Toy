/*
    Copyright 2021 Picovoice Inc.

    You may not use this file except in compliance with the license. A copy of the license is located in the "LICENSE"
    file accompanying this source.

    Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
    an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
    specific language governing permissions and limitations under the License.
*/

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

// STM32 specific includes
#include "stm32f411e_discovery.h"
#include "stm32f4xx_hal.h"

// Picovoice includes
#include "pv_porcupine.h"
#include "pv_porcupine_mcu.h"
#include "pv_audio_rec.h"
#include "pv_st_f411.h"

// Define memory buffer size (adjust as needed based on your system requirements)
#define MEMORY_BUFFER_SIZE (50 * 1024)

// Memory buffer with alignment
static uint8_t memory_buffer[MEMORY_BUFFER_SIZE] __attribute__((aligned(16)));

// Access key placeholder - replace with your actual access key
static const char *ACCESS_KEY = "s9IfnkWz2W+0geJD7pGNO70H8rADJUjEC+5LpJ3nIP0wV+MtAauCpw==";

// Keyword array from pv_porcupine_params.h
static const uint8_t keyword_array[700] __attribute__ ((aligned (16))) = {
        0xc9, 0x19, 0xeb, 0xf0, 0x0c, 0xc4, 0x0e, 0x5f, 0xf6, 0xce, 0xad, 0xe3, 0xbe, 0x96, 0x6f, 0xae, 0x08, 0x3c,
        0x66, 0xe2, 0x59, 0x35, 0x45, 0x8e, 0x9e, 0x3c, 0x55, 0x4b, 0x1c, 0xce, 0xae, 0x58, 0xf1, 0x43, 0x7f, 0x2b,
        0x7f, 0xb8, 0x96, 0xa2, 0x05, 0xe6, 0xc7, 0xb6, 0x79, 0xbc, 0xe0, 0x17, 0xb5, 0xdf, 0x8c, 0x6b, 0x5b, 0x36,
        0xe5, 0x3f, 0x5b, 0x7a, 0x8e, 0x93, 0x7d, 0x42, 0xd2, 0xca, 0x01, 0xf3, 0x9c, 0x44, 0xcc, 0x5f, 0xb9, 0x86,
        0xca, 0x91, 0xf6, 0x05, 0xfc, 0xdd, 0xbd, 0xb0, 0xaa, 0xe3, 0x48, 0xe2, 0xc4, 0x25, 0x5d, 0x66, 0x71, 0xd8,
        0xa2, 0xb2, 0xac, 0x20, 0x9c, 0xb4, 0x4b, 0xcf, 0x63, 0xed, 0xd4, 0xb7, 0xab, 0x3d, 0xae, 0xdd, 0x7b, 0x18,
        0x8f, 0x04, 0x38, 0x38, 0x49, 0x53, 0xf6, 0x0b, 0x68, 0xfc, 0xe5, 0xa8, 0x53, 0xb6, 0xb7, 0x0d, 0x52, 0x98,
        0xf3, 0xf2, 0xa7, 0x8f, 0x9d, 0xc9, 0x98, 0xfd, 0x33, 0x78, 0x28, 0xff, 0xdf, 0x43, 0xd1, 0xc8, 0xe7, 0x76,
        0xc9, 0x08, 0x94, 0x3b, 0x72, 0x13, 0x41, 0x20, 0xcf, 0xc9, 0x6b, 0x1b, 0x52, 0xa8, 0x88, 0xd9, 0xf6, 0xaa,
        0x24, 0x00, 0x53, 0x06, 0xda, 0x03, 0xd5, 0xf9, 0x0f, 0xf7, 0x79, 0x4b, 0xc3, 0x09, 0x4e, 0x05, 0x60, 0x63,
        0x77, 0x5b, 0xc0, 0xfa, 0x0a, 0x19, 0x78, 0x9b, 0x73, 0xb3, 0x2b, 0xe8, 0xeb, 0x8a, 0x0d, 0x41, 0x4e, 0x19,
        0xd5, 0xb9, 0x3b, 0x93, 0xd5, 0x72, 0xd0, 0x57, 0xd8, 0x47, 0xcf, 0x17, 0x9b, 0x32, 0x7a, 0x6c, 0x06, 0x88,
        0x29, 0x9b, 0x77, 0x1d, 0x5d, 0xbc, 0x41, 0x8c, 0xd0, 0x9a, 0x40, 0x53, 0xab, 0xbf, 0x9d, 0x67, 0xb2, 0x94,
        0xb5, 0x6d, 0x44, 0x23, 0x57, 0x9e, 0x15, 0x22, 0x3b, 0x9e, 0x0c, 0xc4, 0x79, 0x90, 0xf4, 0xb2, 0x48, 0x59,
        0x02, 0xa5, 0x11, 0x05, 0x74, 0xf7, 0x04, 0x2a, 0xb0, 0xac, 0x6d, 0xdc, 0x8e, 0x90, 0xfe, 0x14, 0xe3, 0x8b,
        0xce, 0x25, 0x21, 0x86, 0xab, 0xfa, 0x99, 0xbc, 0x88, 0x1f, 0xce, 0x92, 0x86, 0x35, 0x52, 0x3f, 0xd4, 0x5e,
        0xc5, 0xd9, 0xd5, 0xf0, 0x55, 0x5d, 0x7f, 0x52, 0x88, 0x34, 0x88, 0x04, 0xe2, 0x6a, 0xa2, 0x17, 0x56, 0x5c,
        0x73, 0x49, 0xc0, 0x02, 0xa7, 0x1d, 0xf0, 0x54, 0xce, 0x7e, 0x7c, 0x17, 0xda, 0x07, 0x9e, 0x8c, 0x1e, 0xb3,
        0xd6, 0x69, 0x6f, 0x86, 0xc9, 0xb5, 0x4f, 0xac, 0x46, 0xe2, 0x08, 0xa5, 0x91, 0x07, 0x5b, 0x60, 0xe0, 0x34,
        0xb1, 0x86, 0xa3, 0xd8, 0x57, 0xd6, 0xcd, 0x85, 0x57, 0x16, 0x26, 0x02, 0x62, 0xc8, 0x78, 0x38, 0x4b, 0x24,
        0xfc, 0xcb, 0x65, 0x5e, 0x7b, 0xe8, 0x82, 0x58, 0x83, 0x24, 0x31, 0xc4, 0x8e, 0x8a, 0x21, 0xd3, 0xf1, 0xa9,
        0xd0, 0xd1, 0xab, 0x75, 0xec, 0xee, 0xe7, 0x9b, 0x94, 0xa7, 0x01, 0x53, 0x6d, 0x0f, 0xb5, 0xe8, 0x2a, 0x54,
        0x59, 0x5c, 0x33, 0x37, 0xac, 0xd2, 0xbf, 0x25, 0x66, 0x44, 0xcc, 0xce, 0xd8, 0x3c, 0xbc, 0x06, 0x89, 0xe3,
        0x76, 0x92, 0x6b, 0x19, 0xf6, 0xa3, 0xb3, 0x60, 0xb2, 0x06, 0x60, 0x9f, 0x66, 0xb7, 0x6b, 0x6d, 0xf9, 0x91,
        0x8d, 0x78, 0xb9, 0x27, 0x1c, 0xe1, 0x74, 0xdd, 0x48, 0x5f, 0x67, 0x0a, 0x67, 0xb1, 0x98, 0x68, 0xdd, 0x3f,
        0x0b, 0xb1, 0x7a, 0x2d, 0xe0, 0xe7, 0xfa, 0xf7, 0xfc, 0x4f, 0xe3, 0x6a, 0x85, 0x3b, 0x13, 0xef, 0xe8, 0xd2,
        0x64, 0xb4, 0x3f, 0xe1, 0x78, 0x38, 0xf7, 0xb6, 0x0f, 0x23, 0x79, 0x5a, 0x48, 0x77, 0x4f, 0x35, 0x25, 0x5d,
        0xe2, 0x99, 0x87, 0x85, 0x91, 0xbc, 0xd3, 0x5b, 0x7d, 0x8e, 0x59, 0x0a, 0xb5, 0x61, 0x12, 0x3e, 0x15, 0x85,
        0x28, 0x5f, 0x8d, 0x0d, 0x3d, 0xe4, 0x1a, 0x83, 0xfd, 0x2c, 0x7e, 0xa7, 0xe0, 0x70, 0x59, 0x6f, 0x8f, 0xc6,
        0x87, 0xd8, 0xb8, 0x6e, 0x00, 0x94, 0x4e, 0x30, 0xfd, 0x81, 0xeb, 0x1a, 0xec, 0xe1, 0x7e, 0xeb, 0x0d, 0x7d,
        0x7b, 0xbb, 0x3a, 0x6a, 0x16, 0x26, 0xa1, 0x70, 0x15, 0xd5, 0xd1, 0x07, 0xb4, 0xf2, 0xe9, 0xc7, 0x26, 0xce,
        0x84, 0x6d, 0x20, 0xe9, 0x09, 0x4d, 0xad, 0xd3, 0x41, 0x92, 0xff, 0xa9, 0x69, 0xe6, 0x8e, 0xf0, 0x2f, 0x25,
        0x03, 0x70, 0xd7, 0x69, 0xd8, 0xb7, 0x39, 0x08, 0xd9, 0x6e, 0xca, 0x70, 0x4c, 0x13, 0x7f, 0xad, 0x3f, 0xda,
        0xfe, 0x45, 0x04, 0x6a, 0x1e, 0xc0, 0xd4, 0xf8, 0xbe, 0xcc, 0x04, 0x25, 0x05, 0x86, 0x1a, 0x28, 0xef, 0xd1,
        0x14, 0xa3, 0x2b, 0x12, 0x69, 0x7b, 0x69, 0x68, 0x25, 0xb4, 0x99, 0x69, 0xdf, 0xe5, 0xfb, 0x35, 0xdd, 0xed,
        0x1d, 0xed, 0xd3, 0x45, 0xf2, 0x04, 0x09, 0x33, 0x64, 0x68, 0xa8, 0x14, 0xac, 0x62, 0x9c, 0x25, 0x21, 0x1e,
        0x61, 0x7c, 0xb1, 0xc3, 0x63, 0x4a, 0x8f, 0xe4, 0x21, 0xf6, 0x7c, 0x74, 0x41, 0xb3, 0xd6, 0x2c, 0x9a, 0xce,
        0xab, 0x98, 0xca, 0x43, 0x82, 0x25, 0x99, 0x2b, 0x79, 0xbd, 0x26, 0xd3, 0x58, 0x65, 0x1f, 0x3e, 0x81, 0x62,
        0xc3, 0xa8, 0x10, 0x5e, 0x30, 0x00, 0x09, 0xc3, 0xa5, 0xf1, 0x20, 0xd9, 0x74, 0x6b, 0x47, 0xc8
};

// Configuration parameters
static const int32_t keyword_model_sizes = sizeof(keyword_array);
static const void *keyword_models = keyword_array;
static const float sensitivity = 0.5f;

// Function declarations
static void error_handler(void);
static void wake_word_callback(void);

void print_error_message(char **message_stack, int32_t message_stack_depth) {
    for (int32_t i = 0; i < message_stack_depth; i++) {
        printf("[%ld] %s\n", i, message_stack[i]);
    }
}

static void wake_word_callback(void) {
    printf("[wake word detected]\n");
    // BSP_LED_On(LED4);  
}

int main(void) {
    // Initialize STM32 board
    pv_status_t status = pv_board_init();
    if (status != PV_STATUS_SUCCESS) {
        error_handler();
    }

    // Initialize LEDs
    // BSP_LED_Init(LED4);

    // Print board UUID
    const uint8_t *board_uuid = pv_get_uuid();
    printf("UUID: ");
    for (uint32_t i = 0; i < pv_get_uuid_size(); i++) {
        printf(" %.2x", board_uuid[i]);
    }
    printf("\r\n");

    // Initialize audio recording
    status = pv_audio_rec_init();
    if (status != PV_STATUS_SUCCESS) {
        printf("Audio init failed with '%s'", pv_status_to_string(status));
        error_handler();
    }

    status = pv_audio_rec_start();
    if (status != PV_STATUS_SUCCESS) {
        printf("Recording audio failed with '%s'", pv_status_to_string(status));
        error_handler();
    }

    // Initialize Porcupine
    pv_porcupine_t *porcupine = NULL;
    char **message_stack = NULL;
    int32_t message_stack_depth = 0;

    status = pv_porcupine_init(
        ACCESS_KEY,
        MEMORY_BUFFER_SIZE,
        memory_buffer,
        1,
        &keyword_model_sizes,
        &keyword_models,
        &sensitivity,
        &porcupine);

    if (status != PV_STATUS_SUCCESS) {
        printf("Porcupine initialization failed with '%s':\n", pv_status_to_string(status));
        pv_get_error_stack(&message_stack, &message_stack_depth);
        print_error_message(message_stack, message_stack_depth);
        pv_free_error_stack(message_stack);
        error_handler();
    }

    // Main processing loop
    uint32_t frame_number = 0;
    while (true) {
        const int16_t *buffer = pv_audio_rec_get_new_buffer();
        if (buffer) {
            int32_t keyword_index;
            const pv_status_t process_status = pv_porcupine_process(porcupine, buffer, &keyword_index);
            
            if (process_status != PV_STATUS_SUCCESS) {
                printf("Porcupine process failed with '%s'\n", pv_status_to_string(process_status));
                error_handler();
            }
            
            if (keyword_index != -1) {
                frame_number = 0;
                wake_word_callback();
            }

            // Turn off LED after 20 frames
            if (frame_number++ > 20) {
                // BSP_LED_Off(LED4);
                frame_number = 0;
            }
        }
    }

    // Cleanup (note: this code will never be reached in this implementation)
    pv_board_deinit();
    pv_audio_rec_deinit();
    pv_porcupine_delete(porcupine);
    return 0;
}

static void error_handler(void) {
    while (true) {}
}